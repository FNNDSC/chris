<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">

<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">

<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-card/paper-card.html">
<link rel="import" href="../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">


<link rel="import" href="shared-styles.html">
<link rel="import" href="./components/chris-plugin-starter.html">
<link rel="import" href="./components/chris-data-selector.html">

<dom-module id="chris-feed">
  <template>
    <style include="shared-styles">
      :host {
        display: flex;
        flex-direction: column;
      }

      .loadingIndicator {
        color: #ffffff;
        text-align: center;
        height: 40px;
        margin: 16px;
      }

      .wrapper {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
        margin-bottom: 10px;
      }

      chris-plugin-starter {
        margin-top: 16px;
      }

      .plugin-instance {
        width: 100%;
        box-sizing: border-box;
        padding: 20px;
        background-color: #d9d9d9;
        border: 1px solid white;
        color: #424242;
        display: flex;
        flex-direction: column;
        position: relative;
        margin-top: 16px;
      }

      .plugin-instance:hover {
        cursor: pointer;
        background-color: white;
        color: black;
      }

      .plugin-info {
        display: flex;
        align-items: center;
      }

      .plugin-instance:hover .avatar {
        color: var(--app-primary-color);
      }

      .avatar {
        height: 40px;
        width: 40px;
        border-radius: 20px;
        font-size: 32px;
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .label {
        position: absolute;
        top: 16px;
        right: 16px;
        border-bottom: 2px solid var(--app-accent-color);
      }

      paper-fab {
        right: 8px;
        top: 72px;
        position: fixed;
        background: var(--app-primary-color-dark);
        z-index: 99;
      }

      @media (min-width: 860px) {
        .plugin-instance {
          max-width: 800px;
        }
      }

      [hidden] {
        display: none;
      }
    </style>

    <a href="/home">
      <paper-fab icon="icons:home"></paper-fab>
    </a>

    <div hidden$="[[!waitingForNewPlugin]]" class="loadingIndicator">
      <paper-spinner active></paper-spinner> Starting process....
    </div>

    <chris-plugin-starter
      hidden$="[[!lastPluginFinishedSuccessfully]]"
      feed="[[feed]]"
      plugins="[[plugins]]"
      on-run-plugin="_runPluginSent"
      ></chris-plugin-starter>

    <div class="wrapper">
      <dom-repeat id="test" items="[[feed]]" indexAs="index" mutable-data>
        <template>
          <div class="plugin-instance">
            <div class="plugin-info">
              <div class="avatar">
                [[item.data.revertedIndex]]
               </div>
              [[item.data.plugin_name]]
            <div class="label">
              [[item.data.status]]
            </div>
            </div>
            <div class="plugin-actions">
              <paper-button hidden$="[[_isPluginRunning(item)]]" data-index$="[[index]]" on-click="toggle">Browse data</paper-button>
              <iron-collapse id$="collapse[[index]]">
                <chris-data-selector
                  data="[[_filterByPluginInstance(index, feedData)]]"
                  ip="[[ip]]"
                  port="[[port]]"
                  namespace="[[namespace]]">
                </chris-data-selector>
              </iron-collapse>
            </div>
          </div class=".plugin-instance">
        </template>
      </dom-repeat>
    </div>
  </template>

  <script>
    class ChrisFeed extends Polymer.Element {
      static get is() { return 'chris-feed'; }

      static get properties() {
        return {
          ip: String,
          port: String,
          namespace: String,
          feed: {
            type: Array,
            observer: '_feedChanged',
          },
          feedData: {
            type: Array,
            observer: '_feedDataChanged',
          },
          plugins: Array,
          waitingForNewPlugin: Boolean,
          lastPluginFinishedSuccessfully: Boolean,
        };
      }

      static get observers() {
        return [
          // Observer method name, followed by a list of dependencies, in parenthesis
          '_feedDeepChanged(feed.*)',
          '_feedDataChanged(feedData.splices)',
        ];
      }

            // Manages the iron-collapse elements
      toggle(event) {
        const collapseElem =
          this.shadowRoot.querySelector('#collapse'+event.currentTarget.dataset.index);
        collapseElem.toggle();
      }

      _feedChanged(current, previous) {
        if (current === undefined) return;

        if (current.length === 0) {
          this.lastPluginFinishedSuccessfully = true;
        } else {
          this.lastPluginFinishedSuccessfully =
            current[0].data.status === 'finishedSuccessfully';
          if (previous === undefined || current.length > previous.length) {
            this.waitingForNewPlugin = false;
          }
          // update indices
          for (let i = 0; i<current.length; i++) {
            this.feed[i].data.revertedIndex = current.length - i;
          }
        }
      }

      _feedDeepChanged(feed) {
        if (feed.path.endsWith('.status')) {
          this.lastPluginFinishedSuccessfully =
            (feed.value === 'finishedSuccessfully');
        }
      }

      _feedDataChanged(feedData) {
        this.$.test.render();
      }

      _runPluginSent() {
        this.lastPluginFinishedSuccessfully = false;
        this.waitingForNewPlugin = true;
      }

      _filterByPluginInstance(pluginInstanceIndex, feedData) {
        // if (data.from instance is plugin instance, show it)
        const target = this.feed[pluginInstanceIndex];
        function myFilter(dataset) {
          // console.log(dataset);
          return dataset.data.plugin_inst_id === target.data.id;
        }
        // console.log(this.feed[pluginInstanceIndex]);
        // console.log(pluginInstanceIndex);
        // console.log(feedData);
        // console.log(this.feedData[index]);
        console.log(feedData.filter(myFilter));
        return feedData.filter(myFilter);
      }

      _isPluginRunning(item) {
        console.log(item);
        console.log(item.data.status === 'started')
        return item.data.status === 'started';
      }
    }

    window.customElements.define(ChrisFeed.is, ChrisFeed);
  </script>
</dom-module>
